```javascript
var a=10;         
function aaa(){             
    console.log(a);
};                    
function bbb(){            
    var a=20;            
    aaa();        
}        
bbb()    //  10      这里面涉及到this指向问题  调用全局中的函数,该函数中的this指向全局的window
```

``` javascript
function A(){                 
    let a=1;                 
    window.B=function(){                     
        console.log(a)                 
    }            
}            
A();            
B();       //这里面也涉及到this指向问题   函数表达式声明函数并赋值给全局window上的B,    其中的this指向window   但是console.log(a)   //  这行代码因为闭包使用了外层函数的变量a,  索引打印出来的值就为1
`A方法执行   全局的B变量上就有函数了,然后调用B就可以打印B了`
```

``` javascript
let getFun = (str) => {
  return 'aa'
}
class Bb {
  constructor() {
      //这里是静态属性的位置
    getFun = (str) => {
      return 'bb'
    }
  }
    //  这里声明的是getFun的原型属性   是挂载到原型上面的
  getA = getFun('a')
}
var bb = new Bb()
console.log(bb.getA)                                ///    aa


//静态属性初始化可以访问自己原型链中的属性或者方法,  因为自己的原型链在自己变量对象的上一层,又因为js中的查找是向上查找的,所以说自己的静态属性的初始化的时候可以访问自己的原型链中的上层属性或者是方法,
`因为原型的属性或方法在静态属性或方法的上一层,所以不能访问自身的静态属性或方法,只能向外层查找`
```

